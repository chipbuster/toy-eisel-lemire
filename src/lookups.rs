use std::convert::{TryFrom, TryInto};
use std::env;

/* This file (generated by build.rs) generates two variables for our usage:
EL_POW10_LUT_MIN, which defines the minimum power of ten (e10) contained in the
lookup table, and EL_POW10_LUT_MIN, which defines the actual lookup table.

This module contains the resulting lookup functions for the Eisel-Lemire
algorithm, along with some tests to validate sanity of the lookup table.
*/
include!(concat!(env!("OUT_DIR"), "/el_lookup_table.rs"));

const BIAS: i16 = 1214;

// All functions in this module return None if the lookup is not present in the
// target table.

pub const fn lut_e10_min() -> i16 {
    EL_POW10_LUT_MIN
}

pub const fn lut_e10_max() -> i16 {
    EL_POW10_LUT_MAX
}

pub fn compute_index(e10: i16) -> Option<usize> {
    usize::try_from(e10 - EL_POW10_LUT_MIN).ok()
}

pub fn get_m64(e10: i16) -> Option<u64> {
    Some(EL_POW10_LUT[compute_index(e10)?].0)
}

pub fn get_m128_hi(e10: i16) -> Option<u64> {
    get_m64(e10)
}

pub fn get_m128_lo(e10: i16) -> Option<u64> {
    Some(EL_POW10_LUT[compute_index(e10)?].1)
}

pub fn get_widebiased_e2(e10: i16) -> Option<i16> {
    let _index = compute_index(e10)?;
    let e10: i64 = e10.into();
    let exp = ((217706i64 * e10) >> 16) + 1087;
    exp.try_into().ok()
}

pub fn get_narrowbiased_e2(e10: i16) -> Option<i16> {
    Some(get_widebiased_e2(e10)? + 64)
}

pub fn print_stuff() {
    println!("Hey there!")
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use num_bigint::BigInt;
    use num_rational::BigRational;
    use num_traits::One;

    fn to_bigrat<T>(x: T) -> BigRational
    where
        BigInt: From<T>,
    {
        BigRational::new(BigInt::from(x), One::one())
    }

    fn u128_to_bigint(mhi: u64, mlo: u64) -> BigInt {
        let mut val: u128 = u128::from(mhi) << 64;
        val |= u128::from(mlo);
        BigInt::from(val)
    }

    /// Compute base * (2 ** exponent)
    fn compute_mult_pow2(base: BigInt, exponent: i16) -> BigRational {
        let x = to_bigrat(base);
        let exp: u32 = exponent.unsigned_abs().into();
        let mult = BigInt::from(1) << exp;
        let powpiece = if exponent < 0 {
            BigRational::new(BigInt::from(1), mult)
        } else {
            BigRational::new(mult, BigInt::from(1))
        };
        x * powpiece
    }

    /// Compute 10 ** exponent as a rational
    fn compute_pow_10(exponent: i16) -> BigRational {
        let ten = BigInt::from(10);
        if exponent >= 0 {
            BigRational::new(ten.pow(exponent.unsigned_abs().into()), BigInt::from(1))
        } else {
            BigRational::new(BigInt::from(1), ten.pow(exponent.unsigned_abs().into()))
        }
    }

    fn lut_e10_values() -> Vec<i16> {
        let num_lut_entries: i16 = EL_POW10_LUT.len().try_into().unwrap();
        let lut_e10_range = EL_POW10_LUT_MIN..EL_POW10_LUT_MIN + num_lut_entries;
        lut_e10_range.collect()
    }

    #[test]
    pub fn lut_highbit_set() {
        for entry in EL_POW10_LUT {
            assert!(entry.0 & (1u64 << 63) != 0, "Zero high bit in LUT");
        }
    }

    #[test]
    pub fn can_get_table_vals() {
        for e10 in lut_e10_values() {
            assert!(get_m64(e10).is_some(), "Failed to get M64 for 10**{}", e10);
            assert!(
                get_m128_hi(e10).is_some(),
                "Failed to get M128_hi for 10**{}",
                e10
            );
            assert!(
                get_m128_lo(e10).is_some(),
                "Failed to get M128_lo for 10**{}",
                e10
            );
            assert!(
                get_widebiased_e2(e10).is_some(),
                "Failed to get widebiased e2 for 10**{}",
                e10
            );
            assert!(
                get_narrowbiased_e2(e10).is_some(),
                "Failed to get narrowbiased e2 for 10**{}",
                e10
            );
        }
    }

    #[test]
    /* Checks that the inequality rules for the m64 portions of the lookup table are
    satisfied. The rule for the m64 components are as follows:

        10 ** E10 >= M64      * (2 ** E2)
        10 ** E10 < (M64 + 1) * (2 ** E2)
    */
    pub fn m64_bounds_satisfied() {
        for e10 in lut_e10_values() {
            let m64 = get_m64(e10).expect("Missing lut value.");
            let e2 = get_narrowbiased_e2(e10).unwrap();
            let e2: i16 = i16::try_from(e2).unwrap() - BIAS;

            let pow10 = compute_pow_10(e10);
            let m64_times_pow2 = compute_mult_pow2(BigInt::from(m64), e2);
            let m64p1_times_pow2 = compute_mult_pow2(BigInt::from(m64) + 1, e2);

            assert!(
                pow10 >= m64_times_pow2,
                "Table check failed for e10 = {}. Require that 10 ** {} >= {} * (2**{})",
                e10,
                e10,
                m64,
                e2
            );
            assert!(
                pow10 < m64p1_times_pow2,
                "Table check failed for e10 = {}. Require that 10 ** {} < ({} + 1) * (2**{})",
                e10,
                e10,
                m64,
                e2
            );
        }
    }

    #[test]
    /* Checks that the inequality rules for the m128 portions of the lookup table are
    satisfied. The rules for the m128 components are as follows:

        10 ** E10 >= M128      * (2 ** E2)
        10 ** E10 < (M128 + 1) * (2 ** E2)
    */
    pub fn m128_bounds_satisfied() {
        for e10 in lut_e10_values() {
            let m128hi = get_m128_hi(e10).expect("Missing lut value.");
            let m128lo = get_m128_lo(e10).expect("Missing lut value.");
            let m128_bint = u128_to_bigint(m128hi, m128lo);
            let e2 = get_widebiased_e2(e10).unwrap();
            let e2: i16 = i16::try_from(e2).unwrap() - BIAS;

            let pow10 = compute_pow_10(e10);
            let m64_times_pow2 = compute_mult_pow2(m128_bint.clone(), e2);
            let m64p1_times_pow2 = compute_mult_pow2(m128_bint.clone() + 1, e2);

            assert!(
                pow10 >= m64_times_pow2,
                "Table check failed for e10 = {}. Require that 10 ** {} >= {:#x} * (2**{})",
                e10,
                e10,
                m128_bint,
                e2
            );
            assert!(
                pow10 < m64p1_times_pow2,
                "Table check failed for e10 = {}. Require that 10 ** {} < ({} + 1) * (2**{})",
                e10,
                e10,
                m128_bint,
                e2
            );
        }
    }
}
