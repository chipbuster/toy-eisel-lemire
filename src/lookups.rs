use std::env;
use std::num::Wrapping;
use std::convert::{TryFrom, TryInto};

/* This file (generated by build.rs) generates two variables for our usage:
EL_POW10_LUT_MIN, which defines the minimum power of ten (e10) contained in the
lookup table, and EL_POW10_LUT_MIN, which defines the actual lookup table.

This module contains the resulting lookup functions for the Eisel-Lemire
algorithm, along with some tests to validate sanity of the lookup table.
*/
include!(concat!(env!("OUT_DIR"), "/el_lookup_table.rs"));

// All functions in this module return None if the lookup is not present in the
// target table.

pub fn compute_index(e10: i16) -> Option<usize> {
    usize::try_from(e10 - EL_POW10_LUT_MIN).ok()
}

pub fn get_m64(e10: i16) -> Option<u64> {
    Some(EL_POW10_LUT[compute_index(e10)?].0)
}

pub fn get_m128_hi(e10: i16) -> Option<u64> {
    get_m64(e10)
}

pub fn get_m128_lo(e10: i16) -> Option<u64> {
    Some(EL_POW10_LUT[compute_index(e10)?].1)
}

pub fn get_widebiased_e2(e10: i16) -> Option<u16> {
    let _index = compute_index(e10)?;
    let exp = ((Wrapping(217706u64) * Wrapping(e10 as u64)).0 >> 16) + 1087;
    let exp = exp.try_into().expect("Could not unwrap widebiased e2!");
    Some(exp)
}

pub fn get_narrowbiased_e2(e10: i16) -> Option<u16> {
    Some(get_widebiased_e2(e10)? - 64u16)
}

pub fn print_stuff() {
    println!("Hey there!")
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use num_bigint::BigUint;

    #[test]
    pub fn lut_highbit_set(){
        for entry in EL_POW10_LUT {
            assert!(entry.0 & (1u64 << 63) != 0, "Zero high bit in LUT");
        }
    }

    #[test]
    // TODO: Finish this test. Note: we need some way to do testing when e10 is
    // < 0 as we can't do division with bigints. Maybe do the whole thing
    // inverted? (Will have to check that math works out correctly)
    pub fn lut_is_lowerbounded(){
        let num_lut_entries: i16 = EL_POW10_LUT.len().try_into().unwrap();
        let lut_e10_range = EL_POW10_LUT_MIN..=EL_POW10_LUT_MIN + num_lut_entries;
        for e10 in lut_e10_range {

        }
    }

    // TODO: Write tests for the following:
    // - M64 (shift) e2 obeys inequalities
    // - M128 (shift) e2 obeys inequalities
}